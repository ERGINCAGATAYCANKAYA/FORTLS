kk <- data[which(data$z >= 1.25 & data$z <= 1.35), ]
k$z <- 1.3
kk$col <- 2
kkk <- data[which(data$z >= 1.55 & data$z <= 1.65), ]
k$z <- 1.6
kkk$col <- 3
all <- rbind(k, kk, kkk)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
k <- data[which(data$z >= 0.95 & data$z <= 1.05), ]
k$z
k$z <- 1
k$z
k$col <- 1
kk <- data[which(data$z >= 1.25 & data$z <= 1.35), ]
k$z
k <- data[which(data$z >= 0.95 & data$z <= 1.05), ]
k$z <- 1
k$col <- 1
kk <- data[which(data$z >= 1.25 & data$z <= 1.35), ]
kk$z <- 1.3
kk$col <- 2
kkk <- data[which(data$z >= 1.55 & data$z <= 1.65), ]
kkk$z <- 1.6
kkk$col <- 3
all <- rbind(k, kk, kkk)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/slices.tiff",
width = 7.5, height = 7.5, units = "cm", res = 300, pointsize=10)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
dev.off()
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/slices.tiff",
width = 16, height = 7.5, units = "cm", res = 300, pointsize=10)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
dev.off()
k <- data[which(data$z >= 0.95 & data$z <= 1.05), ]
k$col <- 1
kk <- data[which(data$z >= 1.25 & data$z <= 1.35), ]
kk$col <- 2
kkk <- data[which(data$z >= 1.55 & data$z <= 1.65), ]
kkk$col <- 3
all <- rbind(k, kk, kkk)
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/slices.tiff",
width = 16, height = 7.5, units = "cm", res = 300, pointsize=10)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
dev.off()
k <- data[which(data$z >= 0.95 & data$z <= 1.05), ]
k$z <- 1
k$col <- 1
kk <- data[which(data$z >= 1.25 & data$z <= 1.35), ]
kk$z <- 1.3
kk$col <- 2
kkk <- data[which(data$z >= 1.55 & data$z <= 1.65), ]
kkk$z <- 1.6
kkk$col <- 3
all <- rbind(k, kk, kkk)
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/slices.tiff",
width = 16, height = 7.5, units = "cm", res = 300, pointsize=10)
scatterplot3d(all$x, all$y, all$z,
# zlim = c(0.5, 2.5),
xlab = "x (m)", ylab = "y (m)", zlab = "z (m)",
axis = T,
grid = F,
mar = c(3, 3, 0, 3),
color = all$col,
box = FALSE, pch = 16, cex.symbols = 0.5)
dev.off()
.dbscan <- dbscan::dbscan(k[, c("x", "y")], eps = .eps)
k$cluster <- .dbscan$cluster
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/clusters.tiff",
width = 7.5, height = 7.5, units = "cm", res = 300, pointsize=10)
plot(k$x, k$y, asp = 1,
xlab = "x (m)", ylab = "y (m)",
xlim = c(-10, 10),
ylim = c(-10, 10),
col = k$cluster)
dev.off()
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/clusters.tiff",
width = 16, height = 16, units = "cm", res = 300, pointsize=10)
plot(k$x, k$y, asp = 1,
xlab = "x (m)", ylab = "y (m)",
xlim = c(-10, 10),
ylim = c(-10, 10),
col = k$cluster)
dev.off()
tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/clusters.tiff",
width = 16, height = 16, units = "cm", res = 300, pointsize=10)
plot(k$x, k$y, asp = 1,
xlab = "x (m)", ylab = "y (m)",
xlim = c(-7.5, 7.5),
ylim = c(-7.5, 7.5),
col = k$cluster)
dev.off()
library(Rcpp)
library(RcppEigen)
sourceCpp("F:/FORTLS_devel/FORTLS/src/surface_variation_1.5.cpp")
source("F:/FORTLS_devel/FORTLS/R/auxiliary.functions.R")
library(Rcpp)
library(RcppEigen)
sourceCpp("F:/FORTLS_devel/src/surface_variation_1.5.cpp")
source("F:/FORTLS_devel/R/auxiliary.functions.R")
sourceCpp("F:/FORTLS_devel/src/surface_variation_1.3.cpp")
source("F:/FORTLS_devel/R/auxiliary.functions.R")
.ncr.threshold <- 0.1
cat(paste("Computing section:", cuts), fill = TRUE)
.cut <- data[which(data$z > (cuts-0.35) & data$z < (cuts+0.35)), ]
breaks
dbh.min = 7.5
dbh.max = 120
tls.resolution = list(point.dist = 7.67, tls.dist = 10)
breaks = 1.6
.dbh.min <- dbh.min / 100
.dbh.max <- dbh.max / 100
# Arguments of the TLS precision
# If resolution is defined by points distance at a certain distance from TLS (mm/m):
.point.dist <- tls.resolution$point.dist / 1000
.tls.dist <- tls.resolution$tls.dist
# If resolution is defined by angles (?):
.vertical.angle <- tls.resolution$vertical.angle * 2 * pi / 360
.horizontal.angle <- tls.resolution$horizontal.angle * 2 * pi / 360
# Angular resolution:
if(is.null(.point.dist)){
.alpha.v <- .vertical.angle
.alpha.h <- .horizontal.angle
} else {
.alpha.v <- atan((.point.dist / 2) / (.tls.dist)) * 2
.alpha.h <- .alpha.v
}
library(Rcpp)
library(RcppEigen)
sourceCpp("F:/FORTLS_devel/src/surface_variation_1.3.cpp")
source("F:/FORTLS_devel/R/auxiliary.functions.R")
.ncr.threshold <- 0.1
cuts <- breaks
.cut <- data[which(data$z > (cuts-0.35) & data$z < (cuts+0.35)), ]
.cut <- .ncr.remove.slice.double(.cut)
.cut <- .cut[which(.cut$ncr < .ncr.threshold | is.na(.cut$ncr)), ]
# Ahora ya si me quedo con la rebanada de 1m +/- 5 cm
# .cut <- .cut[which(.cut$z > (cuts-0.05) & .cut$z < (cuts+0.05)), ]
# .cut <- .cut[which(.cut$z > (cuts-0.1) & .cut$z < (cuts+0.1)), ]
.cut <- .cut[which(.cut$z > (cuts-0.30) & .cut$z < (cuts+0.30)), ]
.cut$col <- "burlywood4"
.cut <- .cut[which(.cut$z > (cuts-0.05) & .cut$z < (cuts+0.05)), ]
all.points <- data[which(data$z > (cuts-0.30) & data$z < (cuts+0.30)), ]
all.points <- merge(all.points[, c("point", "x", "y", "z")], .cut[, c("point", "col")], by = "point", all = TRUE)
all.points$col <- ifelse(is.na(all.points$col), "forestgreen", all.points$col)
# Dbscan parameters
.eps <- .dbh.min / 2
# Clustering
.dbscan <- dbscan::dbscan(.cut[, c("x", "y")], eps = .eps)
.cut$cluster <- .dbscan$cluster
.cut <- .cut[which(.cut$cluster > 0), ]
.cut$sec <- cuts
.filter <- data.frame(cluster = as.numeric(),
# Center coordinates
center.x = as.numeric(), center.y = as.numeric(),
center.phi = as.numeric(), center.rho = as.numeric(),
center.r = as.numeric(), center.theta = as.numeric(),
# Radius
radius = as.numeric(),
# Number of points belowing to cluster (craw and after point crooping)
num.points = as.numeric(), num.points.hom = as.numeric(),
# Phi coordinates of left and right
phi.left = as.numeric(), phi.right = as.numeric(),
# Circunference arc
arc.circ = as.numeric(),
# Partial occulion
occlusion = as.numeric())
unique(.cut$cluster)
.i <- 241
# tiff("C:/Users/JUAN/Google Drive/Doctorado/TLS/FORTLS/EnviromentalModellingSoftware/figuras/Fig_3.tiff",
#      width = 16, height = 16, units = "cm", res = 300, pointsize=10)
par(mfrow=c(2,2))
par(mar = c(4, 4, 4, 4))
# Selecionamos el cluster i
# .i <- 5
.i <- 122
# .i <- 61
.cluster <- .i
.dat <- .cut[which(.cut$cluster == .i), ]
.x.rang <- max(.dat$x) - min(.dat$x)
.y.rang <- max(.dat$y) - min(.dat$y)
.phi.rang <- max(.dat$phi) - min(.dat$phi)
.rho.rang <- max(.dat$rho) - min(.dat$rho)
# Ahora se calculan las coordendas de los centroides con respecto al TLS:
.x.cent <- (.x.rang / 2) + min(.dat$x)
.y.cent <- (.y.rang / 2) + min(.dat$y)
.phi.cent <- (.phi.rang / 2) + min(.dat$phi)
.rho.cent <- (.rho.rang / 2) + min(.dat$rho)
# Se obtiene el ancho de la malla cuadrada que se aplicar? sobre el cl?ster
.ancho.malla <- (max(.x.rang, .y.rang) / 2) * 1.5
# Coordenadas m?ximas y m?nimas de la malla
.xmin <- .x.cent - .ancho.malla
.ymin <- .y.cent - .ancho.malla
.xmax <- .x.cent + .ancho.malla
.ymax <- .y.cent + .ancho.malla
# Ahora se obtiene una segunda malla basada en las coornadas cil?ndricas phi y rho.
# Esta se utilizar? para calcular la densidad media de puntos por celda
.ancho.malla.2 <- (max(.phi.rang, .rho.rang) / 2)
.phimin <- .phi.cent - .ancho.malla.2
.rhomin <- .rho.cent - .ancho.malla.2
.phimax <- .phi.cent + .ancho.malla.2
.rhomax <- .rho.cent + .ancho.malla.2
# Filtro
.x.values <- seq(from = .xmin, to = .xmax, by = 0.03)
.y.values <- seq(from = .ymin, to = .ymax, by = 0.03)
.density <- matrix(0, ncol = length(.x.values), nrow = length(.y.values))
for(.i in 1:length(.x.values)){
for(.j in 1:length(.y.values)){
.den <- .dat[which(.dat$x < ((.x.values[.i]) + 0.015) &
.dat$x > ((.x.values[.i]) - 0.015) &
.dat$y < ((.y.values[.j]) + 0.015) &
.dat$y > ((.y.values[.j]) - 0.015)), ]
# Aquellas celdas con menos de 2 puntos no las tengo en cuenta
# para luego m?s tarde calcular la densidad media por celda
.density[.j, .i] <- ifelse(nrow(.den) < 1, NA, nrow(.den))
}
}
# Estmiaci?n de la densidad media por celda
par(mar = c(4, 4, 2, 1))
plot(.dat$x, .dat$y, col = "grey", asp = 1, pch = 20, main = .cluster,
xlab = "x(m)", ylab = "y(m)")
.threeshold <- mean(.density, na.rm = T)
if(is.nan(.threeshold)){next}
.density <- matrix(0, ncol = length(.x.values), nrow = length(.y.values))
.remove <- data.frame(point = as.numeric())
for(.i in 1:length(.x.values)){
for(.j in 1:length(.y.values)){
# points(.x.values[.i], .y.values[.j], pch = 15, cex = 1.25, col = alpha("blue", 0.25))
.den <- .dat[which(.dat$x < ((.x.values[.i]) + 0.015) &
.dat$x > ((.x.values[.i]) - 0.015) &
.dat$y < ((.y.values[.j]) + 0.015) &
.dat$y > ((.y.values[.j]) - 0.015)), ]
# Aquellas celdas con menos de 2 puntos no las tengo en cuenta
# para luego m?s tarde calcular la densidad media por celda
.density[.j, .i] <- ifelse(nrow(.den) < 1, NA, nrow(.den))
if(nrow(.den) > .threeshold){
# points(.x.values[.i], .y.values[.j], pch = 22, col = alpha("green", 0.5))
.rem <- data.frame(point = .den$point)
.remove <- rbind(.remove, .rem)
}
if(nrow(.den) < .threeshold & nrow(.den) > 0){
# points(.x.values[.i], .y.values[.j], pch = 22, col = alpha("red", 0.5))
}
}
}
# .remove$remove <- 2
# .dat$remove <- 1
# .dat.remove <- merge(.dat, .remove, by = "point", all = TRUE)
# .dat.remove <- .dat.remove[which(is.na(.dat.remove$remove.y)), ]
.dat <- merge(.dat, .remove, by = "point", all.y = TRUE)
# points(.dat.remove$x, .dat.remove$y, pch = 13, col = "red")
points(.dat$x, .dat$y, pch = 1, col = "green")
abline(v = .x.values - 0.015, col = alpha("blue", 0.25))
abline(h = .y.values - 0.015, col = alpha("blue", 0.25))
abline(v = .x.values - 0.015, col = scales::alpha("blue", 0.25))
abline(h = .y.values - 0.015, col = scales::alpha("blue", 0.25))
legend("topleft", "b)", bty="n", cex = 1.5)
legend("topright", cex = 1.25,
legend=c("Retained", "Removed"),
pch = c(1, 13), col = c("green", "red"))
# .n <- 0.7 * (0.1 / (tan(.alpha.h / 2) * mean(.dat$rho) * 2)) * (0.001 / .alpha.h)
# .n <- 0.7 * (0.1 / (tan(.alpha.h / 2) * mean(.dat$rho, na.rm = T) * 2)) * (0.001 / .alpha.h)
.n <- (0.1 / (tan(.alpha.v / 2) * (mean(.dat$r) / cos(mean(.cut$slope, na.rm = TRUE))) * 2))
# Valores de las coordenadas phi y rho correspondientes a las
# intersecciones de la malla:
.x2.values <- seq(from = .phimin, to = .phimax, by = 0.001)
.y2.values <- seq(from = .rhomin, to = .rhomax, by = 0.04)
# Matriz donde se va a almacenar el n?mero de puntos por celda
.density <- matrix(0, ncol = length(.x2.values), nrow = length(.y2.values))
.remove <- data.frame(point = as.numeric())
.dat <- .dat[which(.dat$z >= 1.55 & .dat$z <= 1.65), ]
plot(.dat$phi, .dat$rho, col = "grey",
xlab = "phi(rad)", ylab = "rho(m)", pch = 20)
for(.i in 1:length(.x2.values)){
for(.j in 1:length(.y2.values)){
.den <- .dat[which(.dat$phi <= ((.x2.values[.i]) + 0.0005) &
.dat$phi >= ((.x2.values[.i]) - 0.0005) &
.dat$rho >= ((.y2.values[.j]) - 0.02) &
.dat$rho >= ((.y2.values[.j]) - 0.02)), ]
# Aquellas celdas con menos de 2 puntos no las tengo en cuenta
# para luego m?s tarde calcular la densidad media por celda
if(nrow(.den) < 2){
.density[.j, .i] <- NA
points(.den$phi, .den$rho, col = "red", pch = 13)
} else{
.density[.j, .i] <- nrow(.den)
}
# .density[.j, .i] <- ifelse(nrow(.den) < 2, NA, nrow(.den))
if(nrow(.den) < .n){
# points(.den$phi, .den$rho, col = "red", pch = 13)
} else {
points(.den$phi, .den$rho, col = "green", pch = 1)
}
if(nrow(.den) > 1){
.rem <- data.frame(point = .den$point)
.remove <- rbind(.remove, .rem)
}
}
}
abline(v = .x2.values - 0.005, col = alpha("blue", 0.25))
abline(h = .y2.values - 0.02, col = alpha("blue", 0.25))
plot(.dat$phi, .dat$z, col = "grey",
xlab = "phi(rad)", ylab = "rho(m)", pch = 20)
plot(.dat$phi, .dat$z, col = "grey",
xlab = "phi(rad)", ylab = "z (m)", pch = 20)
for(.i in 1:length(.x2.values)){
for(.j in 1:length(.y2.values)){
.den <- .dat[which(.dat$phi <= ((.x2.values[.i]) + 0.0005) &
.dat$phi >= ((.x2.values[.i]) - 0.0005) &
.dat$rho >= ((.y2.values[.j]) - 0.02) &
.dat$rho >= ((.y2.values[.j]) - 0.02)), ]
# Aquellas celdas con menos de 2 puntos no las tengo en cuenta
# para luego m?s tarde calcular la densidad media por celda
if(nrow(.den) < 2){
.density[.j, .i] <- NA
points(.den$phi, .den$rho, col = "red", pch = 13)
} else{
.density[.j, .i] <- nrow(.den)
}
# .density[.j, .i] <- ifelse(nrow(.den) < 2, NA, nrow(.den))
if(nrow(.den) < .n){
# points(.den$phi, .den$rho, col = "red", pch = 13)
} else {
points(.den$phi, .den$rho, col = "green", pch = 1)
}
if(nrow(.den) > 1){
.rem <- data.frame(point = .den$point)
.remove <- rbind(.remove, .rem)
}
}
}
abline(v = .x2.values - 0.005, col = alpha("blue", 0.25))
abline(h = .y2.values - 0.02, col = alpha("blue", 0.25))
abline(v = .x2.values - 0.005, col = scales::alpha("blue", 0.25))
abline(h = .y2.values - 0.02, col = scales::alpha("blue", 0.25))
plot(.dat$phi, .dat$z, col = "grey",
xlab = "phi(rad)", ylab = "z (m)", pch = 20)
for(.i in 1:length(.x2.values)){
for(.j in 1:length(.y2.values)){
.den <- .dat[which(.dat$phi <= ((.x2.values[.i]) + 0.0005) &
.dat$phi >= ((.x2.values[.i]) - 0.0005) &
.dat$rho >= ((.y2.values[.j]) - 0.02) &
.dat$rho >= ((.y2.values[.j]) - 0.02)), ]
# Aquellas celdas con menos de 2 puntos no las tengo en cuenta
# para luego m?s tarde calcular la densidad media por celda
if(nrow(.den) < 2){
.density[.j, .i] <- NA
points(.den$phi, .den$rho, col = "red", pch = 13)
} else{
.density[.j, .i] <- nrow(.den)
}
# .density[.j, .i] <- ifelse(nrow(.den) < 2, NA, nrow(.den))
if(nrow(.den) < .n){
# points(.den$phi, .den$rho, col = "red", pch = 13)
} else {
points(.den$phi, .den$z, col = "green", pch = 1)
}
if(nrow(.den) > 1){
.rem <- data.frame(point = .den$point)
.remove <- rbind(.remove, .rem)
}
}
}
abline(v = .x2.values - 0.005, col = scales::alpha("blue", 0.25))
abline(h = .y2.values - 0.02, col = scales::alpha("blue", 0.25))
legend("topleft", "c)", bty="n", cex = 1.5)
legend("topright", cex = 1.25,
legend=c("Cells above threshold", "Cells bellow threshold", "Removed"),
pch = c(1, 20, 13), col = c("green", "grey", "red"))
library(FORTLS)
setwd("C:/prueba_Oscar")
dir.data <- "C:/prueba_Oscar"
dir.result <- "C:/prueba_Oscar"
sim.fix.A <- read.csv("C:/prueba_Oscar/RodalA_mb/simulations.fixed.area.plot.csv")
sim.fix.B <- read.csv("C:/prueba_Oscar/RodalB_f/simulations.fixed.area.plot.csv")
sim.tree.A <- read.csv("C:/prueba_Oscar/RodalA_mb/simulations.k.tree.plot.csv")
sim.tree.B <- read.csv("C:/prueba_Oscar/RodalB_f/simulations.k.tree.plot.csv")
sim.angle.A <- read.csv("C:/prueba_Oscar/RodalA_mb/simulations.angle.count.plot.csv")
sim.angle.B <- read.csv("C:/prueba_Oscar/RodalB_f/simulations.angle.count.plot.csv")
unique(sim.fix.A$id)
sim.fix <- rbind(sim.fix.A, sim.fix.B)
sim.tree <- rbind(sim.tree.A, sim.tree.B)
sim.angle <- rbind(sim.angle.A, sim.angle.B)
kk <- subset(sim.angle, BAF == "0.4")
plot(kk$N.pam, kk$N)
fit <- lm(N ~ N.pam, data = kk)
summary(fit)
t <- c(1:1000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.angle.A$N.pam[which(sim.angle.A$BAF == "0.4")]
mean(est.N)
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.angle.B$N.pam[which(sim.angle.B$BAF == "0.4")]
mean(est.N)
kk <- subset(sim.tree, k == "12")
plot(kk$N.hr, kk$N)
fit <- lm(N ~ N.hr, data = kk)
summary(fit)
t <- c(1:10000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.A$N.hr[which(sim.tree.A$k == "7")]
mean(est.N)
kk <- subset(sim.tree, k == "7")
plot(kk$N.hr, kk$N)
fit <- lm(N ~ N.hr, data = kk)
summary(fit)
t <- c(1:10000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.A$N.hr[which(sim.tree.A$k == "7")]
mean(est.N)
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.B$N.hr[which(sim.tree.B$k == "7")]
mean(est.N)
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.A$N.hr[which(sim.tree.A$k == "7")]
mean(est.N)
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.B$N.hr[which(sim.tree.B$k == "7")]
mean(est.N)
kk <- subset(sim.fix, radius == "6.2")
plot(kk$N.sh, kk$N)
fit <- lm(N ~ N.sh, data = kk)
summary(fit)
t <- c(1:1000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.fix.A$N.sh[which(sim.fix.A$radius == "6.2")]
mean(est.N)
est.N <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.fix.B$N.sh[which(sim.fix.B$radius == "6.2")]
mean(est.N)
kk <- subset(sim.tree, k == "11")
plot(kk$hg.tls, kk$h.0)
fit <- lm(h.0 ~ hg.tls, data = kk)
summary(fit)
t <- c(1:100000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.h.0 <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.A$hg.tls[which(sim.tree.A$k == "7")]
mean(est.h.0)
est.G <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.tree.B$hg.tls[which(sim.tree.B$k == "7")]
mean(est.G)
kk <- subset(sim.fix, radius == "10")
plot(kk$hg.0.tls, kk$h.0)
fit <- lm(h.0 ~ hg.0.tls, data = kk)
summary(fit)
t <- c(1:100000)
y1 <- coefficients(fit)[1] + coefficients(fit)[2] * t
lines(t,y1, col="blue")
est.h.0 <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.fix.A$hg.0.tls[which(sim.fix.A$radius == "10")]
mean(est.h.0)
est.h.0 <- coefficients(fit)[1] +
coefficients(fit)[2] *
sim.fix.B$hg.0.tls[which(sim.fix.B$radius == "10")]
mean(est.h.0)
